## 剪绳子
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：
```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```
示例 2:
```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

## 方法1：动态规划

### 分析
通过动态规划来解决，例如已知当绳子长度小于5的时候的最大乘积为。其中由于绳子必须长度大于1，因此下标i从绳长为2开始计算   
```
dp[ 0 ] = 1   // 注意，这里的下标0实则表示绳子长度为2
dp[ 1 ] = 2
dp[ 2 ] = 4
```
那么需要计算`dp[3]`,即绳长为5的时候可以划分为`dp[0]`*`dp[ 1 ]`，即2绳长和3绳长，这里需要注意的是，2绳长本身的长度大于`dp[ 0 ]`，因此不需要再对2绳进行拆分，因此取数值2即可，`dp[ 1 ]`同理，去数值3，最后即得到
```
dp[ 3 ] = 2 * 3 = 6
```
后续同理，但是需要注意的是，5绳既然拆分成2和3，就不要再计算3和2，即循环结果
```
length = Math.floor(i/2);
```
若没超过，则进行对比取最大值，例如6绳可以分割为2和4、3和3，则取其中最大值即可，例如6绳实则表达式为
```
f(6) = Math.max(f(2) * f(4), f(3) * f(3));
```

即：
```
dp[ 4 ] = Math.max(dp[ 0 ] * dp[ 2 ], dp[ 1 ] * dp[ 1 ]);
```


### 解答
```javascript
var cuttingRope = function(n) {
  const dp = [1, 2, 4];
  if (n <= 4) return dp[ n - 2 ];
  // 先从5绳开始
  for (let i = 3; i <= n-2; i++ ) {
    const mid = i >>> 1;
    // 从2绳开始分割
    for (let j = 0; j <= mid; j++) {
      const x = j < 3 ? j + 2 : dp[ j ];
      const diff = i - j - 2;
      const y = diff < 3 ? diff + 2 : dp[ diff ];
      dp[ i ] = Math.max(dp[ i ] || Number.MIN_SAFE_INTEGER, x * y);
    }
  }
  return dp[ dp.length - 1 ];
};
```

## 方法2：贪心算法

### 解析
当 `n >= 5` 时，尽可能的剪长度为`3`的绳子；当剩下绳子长度为`4`时，把绳子剪成两端长度为`2`的绳子。  
这里为什么要从`5`取`3`开始划分呢？因为当`4`绳需要取最大的时候即`2*2`为`4`这个时候是相等的，没有划分的必要。那么`5`取`3`可以得到最大为`6`，关键点在于要从有差异化的阶段开始算起。

### 解答
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var cuttingRope = function(n) {
  if (n < 2) return 0;
  if (n < 4) return n - 1;
  let timersOf3 = Math.floor(n/3);
  const digital = n%3;
  if (digital !== 0) timersOf3--;
  return Math.pow(3, timersOf3) * (digital === 1 ? 4 : digital === 2 ? 6 : 1);
};
```