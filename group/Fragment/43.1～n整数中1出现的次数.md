## 1 ～ n 整数中 1 出现的次数

输入一个整数 n ，求 1 ～ n 这 n 个整数的十进制表示中 1 出现的次数。

例如，输入 12，1 ～ 12 这些整数中包含 1 的数字有 1、10、11 和 12，1 一共出现了 5 次。

示例 1：

```
输入：n = 12
输出：5
```

示例 2：

```
输入：n = 13
输出：6
```

限制：

```
1 <= n < 2^31
```

From: [1 ～ n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof)

## 分析

首先排除暴力法，因为若 n 非常大时，最后会超时，因此这里可以主动去找 1 可能出现的位置。这里通过高位逐渐扫到低位去寻找各个位置出现`1`的情况。要明确一点,当扫描位为`1`时，其出现的次数和能满足情况的低位的次数一致，并且是它高位出现的倍率。

假设数字`2102`,首先扫描千位,当千位为`1`时，满足的情况有

```
1000 ~ 1999
```

即仅仅只有这 1000 个数，哪怕高位再高，为`9` 也仅仅是这些位。  
当前已经是最高位，因此倍率为`1`，关于倍率的解释可见百位。  
那么当前千位出现为`1` 的次数总计为`1000`，即`1999 - 1000 + 1 = 1000`

再看千位，同样看百位所有`1`的情况

```
100 ~ 199
```

可是当千位为`2`的时候，是不能填满这个条件的，因此当融合千位的时候可以分为两个部分来看，即

```
100 ~ 2000
2000 ~ 2102
满足条件的有：
100 ~ 199
1100 ~ 1199
2100 ~ 2102
```

这里即可得出，除了`千2`开头的数，其他出现的次数都是`100`，因此这里单独剔出`千2`来计算，即`100 * 2 + (102 - 100 + 1) = 203`  
千位出现的`空`,`1`,`2`即之前说的倍数，可以通过计算`2102/当前10的位数`得出，得到的值再`+1`即为可出现的倍数`3`，`+1`是因为考虑到位`空`的场景。若是数字`2202`的话，则直接`100 * 3`即可，但这里有边界需要考虑。

这里预先得到十位的倍数`2102/100 = 21`，当这里需要考虑的是，当前十位为 0，是不可能计算到`2110`来的，因此这里就需要`-1`了。例如数字`100`也是同样的道理。这里倍数为`21`，那么这高位`21`种情况是必定满足`10 ~ 2019`的，因此直接`21 * (19 - 10 + 1) = 210`, 这里为了方便计算，可以将`0`改为`9`，代表该数必定满足情况。

再计算个位，个位`2 > 1`，因此所有倍率都满足情况，即`(210 + 1) * 1 = 211`

最后结果即为`1000 + 203 + 210 + 211 = 1624`

最后总结：当前位出现`1`的次数需要乘`高位的倍率 + 1`，若最高位没有填满条件，则需要剔出一个倍数进行单独运算。 若当前位为`0`，需要`-1`倍数，并且在下次运算时填充`9`(填充比 1 大的单位数字都行)。最后再将各个位置出现的`1`的次数相加。

## 解答

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var countDigitOne = function(n) {
  let num = n;
  let res = 0;
  let multi = 1;
  let pow = 10 ** (String(num).length - 1);
  while (pow >= 1) {
    if (2 * pow - 1 <= num) {
      res += pow * multi;
    } else {
      res += num - pow + 1 + pow * (multi - 1);
    }
    multi = Math.floor(n / pow) + 1;
    num %= pow;
    pow /= 10;
    if (num < pow) {
      num += 9 * pow;
      multi--;
    }
  }
  return res;
};
```

## 扩展：2 的出现次数

```javascript
// 2的出现次数主要存在于 200~299 之类的
var numberOf2sInRange = function(n) {
  const len = String(n).length - 1;
  let pow = 10 ** len;
  let multi = 1;
  let curr = n;
  let res = 0;
  while (pow >= 1) {
    if (curr >= 3 * pow - 1) {
      res += pow * multi;
    } else {
      res += (multi - 1) * pow;
      if (curr >= 2 * pow) {  // 这个地方需要单独判断
        res += (curr % pow) + 1;
      }
    }
    multi = Math.floor(n / pow) + 1;
    curr %= pow;
    pow /= 10;
    if (curr < pow) {
      curr += 9 * pow;
      multi--;
    }
  }
  return res;
};
```
