<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <style>
    div {
      background-color: red;
      border: 10px #000;
    }
  </style>
  <body>
    <script>
      /*
      在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

      示例 1:
      // min = 2
      // curr = ListNode();
      输入: 4->2->1->3
      输出: 1->2->3->4
      示例 2:

      输入: -1->5->3->4->0
      输出: -1->0->3->4->5

     TreeNode {
  val: 1,
  right: TreeNode { val: 1, right: null, left: null },
  left:
   TreeNode {
     val: 0,
     right: TreeNode { val: -3, right: null, left: null },
     left: TreeNode { val: -4, right: null, left: null } } }
     
     TreeNode {
  val: 1,
  right: null,
  left: TreeNode { val: -4, right: null, left: null } }
      */
      var uniquePathsWithObstacles = function(obstacleGrid) {
        if (!obstacleGrid.length) return 0;
        const vertical = obstacleGrid.length - 1;
        if (!obstacleGrid[0].length) return 0;
        const row = obstacleGrid[0].length - 1;
        if (obstacleGrid[vertical][row] === 1 || obstacleGrid[0][0] === 1) return 0;
        const dp = [];
        for (let i = 0; i <= vertical; i++) {
          for (let j = 0; j <= row; j++) {
            if (obstacleGrid[ i ][ j ] === 1) {
              dp[ j ] = 0;
            } else {
              dp[ j ] = i === 0 && j === 0 ? 1 : ~~dp[ j - 1 ] + ~~dp[ j ]
            }
          }
        }
        return dp[row];
      };
      console.log(
        uniquePathsWithObstacles([
          [0,1,0,0,0],[1,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]
        ])
      );
    </script>
  </body>
</html>
