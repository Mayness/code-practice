## 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

<img src="../../../static/不同路径.png">

例如，上图是一个 7 x 3 的网格。有多少可能的路径？

说明：m 和 n 的值均不超过 100。

示例 1:

```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

示例 2:

```
输入: m = 7, n = 3
输出: 28
```

## 解法 1：动态规划

### 分析

和丢鸡蛋唯一区别是，这里是计算有多少种方法，而不是有多少种步数，因此不用加 1  
公式：

```
f(n, m) = f(n - 1, m) + f(n, m-1);
```

### 解答

```javascript
var uniquePaths = function(m, n) {
  const dp = [];
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (i === 0 || j === 0) {
        dp[i] = dp[i] || [];
        dp[i][j] = dp[i][j] || 1;
      } else {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
      }
    }
  }
  return dp[n - 1][m - 1];
};
```

## 解法 2：动态规划 + 图形压缩

### 分析

在方法 1 的基础上，将 2 维数组转化为 1 维数组，已知公式

```
f(n, m) = f(n - 1, m) + f(n, m-1);
```

在这个基础上面可以复用层面`n`，将现有的计算结果在当前层面进行覆盖，即

```
f(m) = oldF(m) + f(m - 1);
```

oldF 即上一次`m`的计算结果，在初始化中 oldF(0)都为 1， 这时候只需要从 F(1)开始计算即可

### 解答

```javascript
var uniquePaths = function(m, n) {
  if (m === 1 || n === 1) return 1;
  const dp = new Array(m).fill(1);
  for (let i = 1; i < n; i++) {
    for (let j = 1; j < m; j++) {
      dp[ j ] += dp[ j - 1 ];
    }
  }
  return dp[ m - 1 ];
};
```
