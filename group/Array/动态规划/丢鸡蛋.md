## 鸡蛋掉落

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

示例 1：

```
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```

示例 2：

```
输入：K = 2, N = 6
输出：3
示例 3：
输入：K = 3, N = 14
输出：4
```
From: [鸡蛋掉落](https://leetcode-cn.com/problems/super-egg-drop/)

## 方法 1：以鸡蛋为中心

### 分析

K 鸡蛋 N 楼层  
假设当前在 x 楼层，1 <= x <= N  
分两种情况：  
摔碎： 鸡蛋少一个 K-1 下一个楼层 x-1  
没摔碎： 鸡蛋不变 K 剩余楼层 N-x  
由于消耗了一次机会，因此需要+1  
需要从不同楼层中从最坏的情况中选出最优的情况  
公式：
F(K, N) = Math.min( min, Math.max( F(K - 1, x - 1), F(K, N - x) ) + 1 )  
已知条件: ( 鸡蛋与楼层的关系, 横轴从 0 递增楼层，纵轴从 0 递增鸡蛋鸡蛋 )

| 鸡蛋 j\楼层 i |  0  |  1  |  2  |  3  |  4  |  5  |
| :-----------: | :-: | :-: | :-: | :-: | :-: | :-: |
|       0       |  0  |  0  |  0  |  0  |  0  |  0  | 0 |
|       1       |  0  |  1  |  2  |  3  |  4  |  5  | 6 |
|       2       |  0  |  1  |
|       3       |  0  |  1  |

保证每一次的概率相同  
注意：为了保证答案的确切性，需要考虑 i，j 为 0 的情况，即没有鸡蛋、没有楼层

### 解答

```javascript
var superEggDrop = function(K, N) {
  const eggArray = [];
  for (let j = 0; j <= K; j++) {
    eggArray[j] = [];
    for (let i = 0; i <= N; i++) {
      if (j === 0) {
        eggArray[0].push(0);
      } else {
        if (j > 1 && i > 1) break;
        eggArray[j].push(i);
      }
    }
  }
  for (let j = 2; j <= K; j++) {
    for (let i = 2; i <= N; i++) {
      let min = Number.MAX_SAFE_INTEGER;
      for (let x = 1; x <= i; x++) {
        min = Math.min(min, Math.max(eggArray[j - 1][x - 1], eggArray[j][i - x]) + 1);
      }
      eggArray[j][i] = min;
    }
  }
  return eggArray[K][N];
};
```

## 方法 2：以剩余的机会为中心

### 分析

以尽可能少的鸡蛋、 当前最少的机会为条件，可以得到扔出的最高楼层的临界点  
只要

例如从之前得到的 10\*50 表格可以得到

| 鸡蛋 j\楼层 i |  0  |                 1                 |  2  |                 3                 |  4  |  5  |  6  |                 7                 |  8  |  9  | 10  |
| :-----------: | :-: | :-------------------------------: | :-: | :-------------------------------: | :-: | :-: | :-: | :-------------------------------: | :-: | :-: | :-: |
|       0       |  0  |                 0                 |  0  |                 0                 |  0  |  0  |  0  |                 0                 |  0  |  0  |  0  | 0 |
|       1       |  0  | <span style="color: red">1</span> |  2  |                 3                 |  4  |  5  |  6  |                 7                 |  8  |  9  | 10  |
|       2       |  0  |                 1                 |  2  | <span style="color: red">2</span> |  3  |  3  |  3  |                 4                 |  4  |  4  |  4  |
|       3       |  0  |                 1                 |  2  |                 2                 |  3  |  3  |  3  | <span style="color: red">3</span> |  4  |  4  |  4  |
|       4       |  0  |                 1                 |  2  |                 2                 |  3  |  3  |  3  |                 3                 |  4  |  4  |  4  |
|       5       |  0  |                 1                 |  2  |                 2                 |  3  |  3  |  3  |                 3                 |  4  |  4  |  4  |

可以得到  
机会为 1 时，最少鸡蛋为 1，最大可测出楼层数为 1  
机会为 2 时，最少鸡蛋为 2，最大可测出楼层数为 3
机会为 3 时，最少鸡蛋为 3，最大可测出楼层数为 7

这里也主要分两种情况
假设从`n`层丢下鸡蛋，有`step`次机会，`i`个鸡蛋  
1、鸡蛋碎了：剩下`step-1`次机会和`i-1`个鸡蛋  
2、鸡蛋没碎：剩下`step-1`次机会和`i`个鸡蛋

得到可以测得的最大楼层，测得的楼层只要达到传入的楼层即可

```
最大楼层数
F(i, step) = F(i-1, step - 1)+F(i, step - 1)+1
```

### 解答

```javascript
var superEggDrop = function(K, N) {
  let step = 0;
  const dp = [Array(K + 1).fill(0)];
  while (dp[step][K] < N) {
    step++;
    for (let i = 0; i <= K; i++) {
      if (i === 0) {
        dp[step] = [0];
      } else {
        dp[step][i] = dp[step - 1][i - 1] + dp[step - 1][i] + 1;
      }
    }
  }
  return step;
};
// 简化为O(K)空间的运算
var superEggDrop = function(K, N) {
  let step = 0;
  const dp = Array(K + 1).fill(0);
  while (dp[K] < N) {
    step++;
    /*
      由 F(i, step) = F(i-1, step - 1)+F(i, step - 1)+1 得出，
      i-1为上一次的运算，i为当前的运算

      由于计算当前运算F(i, step)需要保留上一次的F(i,step-1)的运算，而不能影响下一次F(i+1,step)

      因此这里需要用逆序来求值，保证每个F(x-1, step-1)都是上一份的计算.
    */
    for (let i = K; i >= 0; i--) dp[i] += dp[i - 1] + 1;
  }
  return step;
};
```
