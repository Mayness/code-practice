## 煎饼排序
给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k <= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。

返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。

 

示例 1：
```
输入：[3,2,4,1]
输出：[4,2,4,3]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 A = [3, 2, 4, 1]
第一次翻转后 (k=4): A = [1, 4, 2, 3]
第二次翻转后 (k=2): A = [4, 1, 2, 3]
第三次翻转后 (k=4): A = [3, 2, 1, 4]
第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。 
```

示例 2：
```
输入：[1,2,3]
输出：[]
解释：
输入已经排序，因此不需要翻转任何内容。
请注意，其他可能的答案，如[3，3]，也将被接受。
```

提示：
```
1 <= A.length <= 100
A[i] 是 [1, 2, ..., A.length] 的排列
```
From: [煎饼排序](https://leetcode-cn.com/problems/pancake-sorting)

## 分析
此题的关键点在于反转数组A的前k个数，那么可以利用这个条件按照从大到小依次将数字进行排列，因为这样可以尽可能的保证提前先将大的数移至末尾而不影响其他的数字，例如`[3,2,4,1]`
```
首先反转数字4，找到其下标为3，那么k = 3，得到
[4,2,3,1]
再将4一次性转到末尾，k = 4，得到
[2,3,1,4]
此时可以不用再观测数字4，可以将原有数组看成[2,3,1]了，接着移动3，找到下标k = 2，得到
[3,2,1]
再全部反转，k = 3
[2,1,3]
同可以不管数字3了，因此可以看成还剩[2,1]，同样的方法再去移动数字2，k = 1
[2,1]
需要注意的是，此时k = 1的话，就不用再进行旋转，因为一个数组长为1反转后也是其本身，因此不用再推入结果到k。直接进行整个反正即可，即k = 2
[1,2]
最后只有1位数字就不用再计算了
```

## 解答
```javascript
/**
 * @param {number[]} A
 * @return {number[]}
 */
var pancakeSort = function(A) {
  let arr = [];
  let curr = A.length;
  while (curr > 1) {
    let index = A.indexOf(curr);
    // 若下标已经和当前位置一致，则不用再替换
    if (index !== curr - 1) {
      if (index !== 0) arr.push(index + 1);
      arr.push(curr);
      A = A.slice(0, index + 1).reverse().concat(A.slice(index + 1)).slice(1, curr).reverse();
    }
    curr--;
  }
  return arr;
};
```